# Result and Analysis {#result-analysis}

In this chapter, the result of the research is shown. The first one is the result from system dependencies gathering. The second one is the Docker images for every combination and its final status. Lastly, the benchmark result is shown.

## System Dependencies

In order to gather all of the system dependencies required by geospatial R packages, R package `sysreqs` is used to access the `sysreqsdb` database. Result for each platform are obtained using this method. These result then used for creating geospatial R Docker images. The full result is available online^[https://github.com/ismailsunni/dockeRs/tree/master/scripts/sysreqs].

## Docker Images

In this section, the exploration's result of each combination between R implementations and platforms for the R installation and geospatial packages installation are shown. The result is described per each R implementations. The overview of the result can be seen in figure \@ref(tab:vanillaRDockerImagesTable) for Docker image without geospatial R package and \@ref(tab:geospatialRDockerImagesTable) for Docker image with geospatial R package.

In those two tables, there are four kind of result. The first one is **Yes** which means that the Docker image is successfully created and it works as expected for this theses. The second result is **No** which means that the Docker image is not possible to create properly. More detail of the failure is explained below. The third one is **Stop**. This result means the Docker image is not created because its geospatial R Docker image will not work properly based on the other Docker image result. And the last one is **?** which means, it may be possible to create the Docker image but is not created because of the time limit.

```{r loadLibraryResultAnalysis, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
library('kableExtra')
library('microbenchmark')
library('altRnative')
```

```{r vanillaRDockerImagesTable, echo=FALSE}
vanillaRDockerImages <- data.frame(
  gnur = c('Yes', 'Yes', 'Yes'),
  mro = c('Yes', 'Yes', 'Yes'),
  renjin = c('Yes', 'Stop', 'Stop'),
  fastr = c('Yes', 'Yes', 'Stop'),
  pqr = c('Yes', 'Stop', 'Stop'),
  terr = c('Yes', 'Stop', 'Stop'),
  row.names = c('Debian', 'Fedora', 'Arch Linux')
  )
vanillaRDockerImages %>%
  kable(
    col.names = c('GNU R', 'MRO', 'Renjin', 'FastR', 'pqR', 'TERR'), 
    caption = "Vanilla R Docker Images",
    align = 'c') %>%
  kable_styling(latex_options = "striped") %>%
  row_spec(0, bold = T) %>%
  column_spec(1, bold = T)
```

```{r geospatialRDockerImagesTable, echo=FALSE}
geospatialRDockerImages <- data.frame(
  gnur = c('Yes', 'Yes', 'Yes'),
  mro = c('Yes', 'Yes', '?'),
  renjin = c('No', 'No', 'No'),
  fastr = c('No', 'No', 'No'),
  pqr = c('No', 'No', 'No'),
  terr = c('No', 'No', 'No'),
  row.names = c('Debian', 'Fedora', 'Arch Linux')
  )
geospatialRDockerImages %>%
  kable(
    col.names = c('GNU R', 'MRO', 'Renjin', 'FastR', 'pqR', 'TERR'), 
    caption = "Geospatial R Docker Images",
    align = 'c') %>%
  kable_styling(latex_options = "striped") %>%
  row_spec(0, bold = T) %>%
  column_spec(1, bold = T)
```

### GNU R

#### Debian

There is Docker image available for GNU R on Debian^[https://hub.docker.com/_/r-base], so there is no need to work on this. This Docker image is created by Rocker Project^[https://www.rocker-project.org/]. This project also provides a GNU R Docker image with geospatial package^[https://hub.docker.com/r/rocker/geospatial]. Unfortunately, this Docker image does not contains all geospatial R package but only for a subset of it. The selected packages are the one which is slow or tricky to install and the one that has general purpose. The geospatial R Docker image for this thesis is created by extending the Rocker Project geospatial R Docker image (adding the missing package). In the end, both Docker image for GNU R on Debian and its geospatial version can be created.

#### Fedora

By using Docker image based on Fedora 32, Docker image for GNU R on Fedora is created. Based on this Docker image, GNU R on Fedora with geospatial is created. There was a problem on installing system dependencies from `sysreqsdb`. The problem is `proj-epsg`, `proj-nad`, and `v8-314-devel` are no longer available. This problem is solved by removing the first two packages and changing the third on to `v8`. In the end, both Docker image for GNU R on Fedora and its geospatial version can be created.

#### Arch Linux

Based on archlinux:20200106 Docker image, GNU R Docker image on Arch Linux is created. From this Docker image, GNU R geospatial Docker image is created. There is a problem on installing system dependencies since not all of the system dependencies are available in the Arch Linux package database. These system dependencies can be installed from Arch User Repository (AUR)^[https://aur.archlinux.org/]. To install a package from AUR on Docker image, it needs to create a user without password. In the end, both Docker image for GNU R on Fedora and its geospatial version can be created.

There is interesting finding on Geospatial GNU R on Arch Linux Docker image. There is a difference behaviour of R code in this Docker image compared to the one on Fedora and Debian. The difference is about CRS comparison. It is caused by different version of GDAL. The Fedora and Debian Docker image have GDAL 2.x while this Arch Linux has GDAL 3.x. The issue has been reported to `sf` issue tracker^[https://github.com/r-spatial/sf/issues/1238].

### Microsoft R Open

#### Debian

There is a Docker image available fro MRO 3.5.3 on Ubuntu 18.04 [@nustNuestMrodocker2019]. From this Docker image, MRO 3.5.3 with geospatial R package is created. There are three problems found. The first one is `libav-tools` is no longer availbale on this Ubuntu version. It's changed with `ffmpeg`. Another issue is `gfortran` which is needed for some R packages is not found on the base image, so it should be installed first. The third one is `polyclip` package can not be installed from within MRO^[https://github.com/ismailsunni/dockeRs/issues/32]. It is solved by installing `polyclip` from source. In the end, both Docker image for MRO 3.5.3 on Ubuntu and its geospatial version can be created.

#### Fedora

There is no Docker image for MRO on Fedora. At first it's created based on the latest version of Fedora (Fedora 32). It works properly until `sf` is tried to installed. There is an error that mentioned `proj_api.h not found in standard or given locations`^[https://github.com/ismailsunni/dockeRs/issues/39]. In the same Docker image, GNU R is installed to check whether the issue is MRO specific or the Docker image specific. It turns out that it is possible to install `sf` on that Docker image for GNU R. In the end, it is solved by using older version of Fedora (Fedora 30). One possibel explanation is that Fedora 32 has `proj` version 6.2 while Fedora 30 has `proj` version 5.2. MRO 3.5.3 is based on GNU R 3.5.3 which has better support for older `proj` version. In the end, both Docker image for MRO 3.5.3 on Fedora 30 and its geospatial version can be created.

#### Arch Linux

The is no official support for Arch Linux from MRO but there is an MRO installer from AUR^[https://aur.archlinux.org/packages/microsoft-r-open/]. By using this package, a Docker image for MRO 3.5.3 on Arch Linux with tag 20200106 is created. Unfortunately, the Docker image for MRO 3.5.3 with geospatial R package is not possible to create using this base image. The reason is because in MRO installed the pinned version of `sf` (based on R 3.5.3) on the snapshot. It expects to have GDAL 2.x which still has `pcs.csv`. This file is removed in GDAL 3.0 which is the current version in the latest Arch Linux.

There is a possibility to downgrade the installed GDAL version to match with the requirement of `sf` in MRO 3.5.3 snapshot. Unfortunately, since the discovery of MRO installer on Arch Linux is very late, the geospatial Docker creation is not done due to time limit. In the end, docke image for MRO 3.5.3 on Arch Linux is created but its geospatial version is not created due to time limit.

### Renjin

Renjin Docker image for Debian is available[@nustNuestRenjindockerDockerfiles2019]. Unfortunately, Renjin doesn't support `sf` [@RenjinOrgSf] because Renjin does not support `units` package [@RenjinOrgUnits] which is needed by `sf`. `units` package is not installed even though `udunits2` is available because Renjin does not support packages that depends on external libraries, in this case `udunits2`[@RccpNotFound]. By the same reasons, Fedora and Arch Linux will not be able to install geospatial packages. Therefore, the Docker image for Renjin on Fedora and Arch Linux are not pursued.

### FastR

#### Debian

There is a Docker image for FastR 3.4.0 on Debian[@nustNuestFastrdocker2019]. But there is a problem on installing `sf` package (one of the core geospatial packages). The problem is related to `proj` not found although it's already installed [@CanNotInstall]. The next attempt is using the latest FastR release 3.6.0, by extending an example from [@CouldnBuildFastr]. Unfortunately, the problem still exists. To check whether this problem is FastR specific or not, GNU R is installed for both Docker images and it's possible to install `sf` on it. This means, the problem is specific to FastR.

Another attempt is using the the official GraalVM Docker image [@OracleGraalvmceDocker] based on Oracle Linux 7. It's possible to install FastR 3.6.1 but not geospatial packages like `sf` because the GDAL is too old on Oracle Linux 7. It is solved by building GDAL from source [@262588213843476InstallGdalRedhat]. Similar problem (old package) also happens with `Pandoc` that is used for running the book knitting in SDSR. This is not mandatory though for geospatial workflow. Unfortunately, there is a code in SDSR book that doesn't run correctly like in GNU R or MRO related to `sf` [@SfInstalledNot].

From these results, it's concluded that it's not possible to install geospatial packages on FastR thus in the case of Arch Linux, it's not explored.


### pqR

There is already pqR Docker image for Debian[@nustNuestPqrdocker2019]. Unfortunately, the latest version of pqR is based on GNU R 2.15.0 [@m.nealPqRPrettyQuick2019]. This makes geospatial packages like `sf` not compatible with it since `sf` needs R version > 3.3.0.[@pebesmaSfSimpleFeatures2019]. Since it is not possible to install geospatial R packages, the Docker images for Fedora and Arch Linux are not created since it will not possible to install geospatial R packages also.

### TIBCO Enterprise Runtime for R (TERR) {#docker-image-terr}

Although TERR is not free and open, TIBCO provides TERR for free with Developer Evaluation license [@TIBCOEnterpriseRuntime]. This license has a limitation which prevent pubslishing the Docker image of TERR[@TIBCOEnterpriseRuntime]. With this limitation, this research only provides Dockerfile to build the Docker image that needs the installer that can be obtained from the TIBCO website. TERR is successfully installed for Debian and Ubuntu. Unfortunately, there is a problem when R geospatial packages are tried to be installed. If there is already a package installed, it is not possible to re-install the package. For example, package `vctrs` is already installed from another R packages installation, if we want to install `RSQLite` which depends on `vctrs` it will turns an error. From this problem, it is not possible to install geospatial packages which have a same R package dependency.

Another problem found is related to `rJava` package. An error message suggest to run `R CMD javareconf` for successful `rJava` installation. Unfortunately, this `javareconf` is not available in TERR.

Since it is not possible to install R geospatial packages with Debian and Ubuntu, we do not continue the exploration for Fedora and Arch Linux.

## Benchmark Tool (`altRnative`)

A new R package name `altRnative` is created to provide functionalities to do benchmark for R script accross different Docker image. `altRnative` uses `microbenchmark` for running the benchmark process and `stevedero` for managing the Docker image and containers. This package is available in GitHub repository, in the following link: `https://github.com/ismailsunni/altRnative`. This package is tested to do benchmark on Spatial Data Science with R Book. To run a benchmark, an R script is needed as the input, and also the list of combination between platform and R implementation.

```{R sdsr_code_benchmark, eval=FALSE}
code = expression(
  setwd('/home/docker/sdsr'), 
  bookdown::clean_book(TRUE), 
  unlink('_book/', recursive=TRUE), 
  unlink('_bookdown_files', recursive=TRUE), 
  bookdown::render_book('index.Rmd', 'bookdown::gitbook')
  )

sdsr_result = benchmarks_code(
  code = code, 
  platforms = c('debian', 'ubuntu', 'fedora', 'archlinux'),
  r_implementations = c('gnu-r', 'mro'), 
  volumes = '/home/ismailsunni/dev/r/sdsr:/home/docker/sdsr', 
  times = 3
  )
```

## Benchmark {#benchmark}

In this section, the result of the benchmark is shown and explained for baseline benchmark and geospatial workflow benchmark

```{r load_data, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
baseline_benchmark = readRDS(file = "./data/simple_benchmark_result.rds")  # 1 + 1
benchmark_result_per_chapter = readRDS(file = "./data/benchmark_result.rds")  # per chapter
sdsr_code_benchmark = readRDS(file = "./data/sdsr_code_benchmark_result.rds") # all code in one run
nano_time_factor = 10^9
options(digits=3)
```

### Baseline Benchmark

`altRnative` package that is used for benchmarking is using Docker images for each R implementation and platform. In this case there is already elapsed time for running the container and destroy it. Baseline benchmark is used to check the time spent for this process. To do it, a very simple R script (`1 + 1`) is run 10 times for each Docker image. The summary can be seen at table \@ref(tab:summaryTableBaseline). It's clear that there is not so much different between Docker images for this baseline benchmark. The distribution of the baseline benchmark is shown in box plot figure \@ref(fig:baseline-benchmark). There are two outliers observation, but in general the result is quite similar within 0.1 second range for the mean.

```{r create_summary_table_baseline, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
summaryTableBaseline <- baseline_benchmark %>% 
      group_by(expr) %>% 
      summarise(mintime = min(time) / nano_time_factor,
                meantime = mean(time) / nano_time_factor,
                mediantime = median(time) / nano_time_factor,
                maxtime = max(time) / nano_time_factor
                )
```

```{r summaryTableBaseline, echo=FALSE, results='hold'}
summaryTableBaseline %>%
  kable(
    "latex",
    col.names = c("Docker Image", "Min", "Mean", "Median", "Max"),
    caption = "Baseline Benchmark",
    booktabs = T) %>%
  kable_styling(
    latex_options = "striped"
    )
```

```{r baseline-benchmark, echo=FALSE, fig.align='center', fig.cap='Baseline Benchmark', fig.width = 10, out.width=400, fig.show='hold'}
benchmark_boxplot(baseline_benchmark, main = 'Baseline Benchmark')
```

### Geospatial Workflow Benchmark

For running geospatial workflow, the code from SDSR book is extracted using an R script to avoid overhead time in knitting the book process. The result of this benchmark can be seen in table \@ref(tab:summaryTableSDSR) and its distribution in box plot figure \@ref(fig:sdsr-benchmark). In this result, there is no outlier for all Docker images. We can see also that GNU R has better compared (~27-28 seconds) to MRO (~33 seconds) regarldess the operating system. For better view of the speed comparison, a normalized time is created by using the mean of time for GNU R on Debian as the baseline. The result is shown in table \@ref(tab:normalizeSummaryTableSDSR). It's clear that MRO needs 1.25x time compared to GNU R.

```{r create_summary_table_sdsr, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
summaryTableSDSR <- sdsr_code_benchmark %>% 
      group_by(expr) %>% 
      summarise(mintime = min(time) / nano_time_factor,
                meantime = mean(time) / nano_time_factor,
                mediantime = median(time) / nano_time_factor,
                maxtime = max(time) / nano_time_factor
                )
```

```{r create_summary_normalize_table_sdsr, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
normalizeSummaryTableSDSR <- sdsr_code_benchmark %>% 
      normalize_benchmark_result('gnu-r on debian') %>%
      group_by(expr) %>% 
      summarise(mintime = min(time),
                meantime = mean(time),
                mediantime = median(time),
                maxtime = max(time)
                )
```

```{r summaryTableSDSR, results='hold', echo=FALSE}
summaryTableSDSR %>%
  kable(
    "latex",
    col.names = c("Docker Image", "Min", "Mean", "Median", "Max"),
    caption = "SDSR Benchmark",
    booktabs = T) %>%
  kable_styling(
    latex_options = "striped"
    )
```

```{r normalizeSummaryTableSDSR, results='hold', echo=FALSE}
normalizeSummaryTableSDSR %>%
  kable(
    "latex",
    col.names = c("Docker Image", "Min", "Mean", "Median", "Max"),
    caption = "Normalized SDSR Benchmark",
    booktabs = T) %>%
  kable_styling(
    latex_options = "striped"
    )
```

```{r sdsr-benchmark, echo=FALSE, fig.align='center', fig.cap='Duration for All Code SDSR Benchmark', fig.width = 10, out.width=400, fig.show='hold'}
benchmark_boxplot(sdsr_code_benchmark, main = 'Duration for All Code SDSR Benchmark')
```

```{r ratio-sdsr-benchmark, echo=FALSE, fig.align='center', fig.cap='Duration Ratio for All SDSR Code', fig.width = 10, out.width=400, fig.show='hide'}
normalize_benchmark_boxplot(
    sdsr_code_benchmark, 
    baseline_image = 'gnu-r on debian', 
    main = 'Duration Ratio for All SDSR Code'
    )
```

It also can be check which chpater of the book that takes the most time to run in table \@ref(tab:longestChapter). Chapter `04-Raster-Cube.R` takes the most of the time compared to other chapters with 26.01 seconds. From here we can examine the benchmark result of chapter `04-Raster-Cube.R`.

Based on table \@ref(tab:Chapter04SummaryTable) the difference between the Docker images are not big. It is more clear in the normalized benchmark table \@ref(tab:Chapter04NormalizedTable) that MRO needs around at most 1.2x time compared to the GNU R one. There is also no outlier in the benchmark `04-Raster-Cube.R` as shown in box plot figure \@ref(fig:Chapter04BoxPlot). Full result for benchmark per chapter can be found in apendix \@ref(apendix-benchmark-per-chapter).

```{r find_longest_chapter, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
library('plyr')
df_chapters <- ldply (benchmark_result_per_chapter, data.frame)
colnames(df_chapters) <- c('chapter', 'dockerimage', 'time')
# Important to unload the package
detach(package:plyr, unload=TRUE)
timePerChapter <- df_chapters %>% 
  select(chapter, time) %>% 
  group_by(chapter) %>% 
  summarise(meantime = mean(time) / nano_time_factor)
```

```{r longestChapter, results='hold', echo=FALSE}
timePerChapter %>%
  kable(
    "latex",
    col.names = c("Chapter", "Mean"),
    caption = "Duration per Chapter for All Docker Images",
    booktabs = T) %>%
  kable_styling(
    latex_options = "striped",
    full_width = T
    )
```

```{r createChapter04SummaryTable, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
chapter04SummaryTable <- benchmark_result_per_chapter[["04-Raster-Cube.R"]] %>% 
      group_by(expr) %>% 
      summarise(mintime = min(time) / nano_time_factor,
                meantime = mean(time) / nano_time_factor,
                mediantime = median(time) / nano_time_factor,
                maxtime = max(time) / nano_time_factor
                )
```

```{r appendixtablechapter04, results='hold', echo=FALSE}
chapter04SummaryTable %>%
  kable(
    "latex",
    col.names = c("Docker Image", "Min", "Mean", "Median", "Max"),
    caption = "Chapter 04 Benchmark",
    booktabs = T) %>%
  kable_styling(
    latex_options = "striped"
    )
```

```{r createChapter04NormalizedTable, included=FALSE, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
chapter04NormalizedTable <- benchmark_result_per_chapter[["04-Raster-Cube.R"]] %>% 
      normalize_benchmark_result('gnu-r on debian') %>%
      group_by(expr) %>% 
      summarise(mintime = min(time),
                meantime = mean(time),
                mediantime = median(time),
                maxtime = max(time)
                )
```

```{r Chapter04NormalizedTable, results='hold', echo=FALSE}
chapter04NormalizedTable %>%
  kable(
    "latex",
    col.names = c("Docker Image", "Min", "Mean", "Median", "Max"),
    caption = "Normalized Chapter 04 Benchmark",
    booktabs = T) %>%
  kable_styling(
    latex_options = "striped"
    )
```

```{r Chapter04BoxPlot, echo=FALSE, fig.align='center', fig.cap='Chapter 04 Benchmark', fig.width = 10, out.width=400, fig.show='hold'}
benchmark_boxplot(benchmark_result_per_chapter[["04-Raster-Cube.R"]], main = 'Chapter 04 Benchmark')
```

```{r NormalizedChapter04BoxPlot, echo=FALSE, fig.align='center', fig.cap='Normalized Chapter 04 Benchmark', fig.width = 10, out.width=400, fig.show='hide'}
normalize_benchmark_boxplot(
    benchmark_result_per_chapter[["04-Raster-Cube.R"]], 
    baseline_image = 'gnu-r on debian', 
    main = 'Normalized Chapter 04 Benchmark'
    )
```
